\chapter{Mises en \oe{}uvres expérimentales}

Toutes ces considérations théoriques, algébriques, sont mises en place depuis les années 1990 par plusieurs acteurs. On voit apparaître des considérations théoriques, notament la machine de Turing quantique par David Deutsch \cite{Deutsch85} qui présente un premier modèle général pour le calcul quantique. 

\section{Processeurs quantiques et langages de programmation}
Le travail de réalisation pratique de processeurs quantique débute en 1988 avec les travaux de Y. Yamamoto et K. Igeta \cite{Igeta:88} démontrant la faisabilité d'un processeur se basant sur les photons, permettant de faire des opérations sur 2 qubits. Depuis les années 1990, plusieurs articles sont publiés proposant des implémentations des différentes portes. 

En 1998, une première implémentation experimentale permet de mettre en oeuvre l'algorithme de Deutsch sur 2 qubits \cite{Chuang1998ExperimentalIO}. En 2000, David DiVincenzo met en place 5 requis théoriques pour la mise en place effective de processeurs quantiques \cite{DiVincenzo_2000} (la possibilité d'avoir un système physique contenant les qubits; la possibilité d'initialiser l'ensemble des qubits à un état initial comme $\ket{000...}$; des temps de décohérence bien supérieurs aux temps d'opération des portes; posséder un ensemble universel de portes quantique; et enfin la possibilité de mesurer les qubits individuellement).

Parallèlement à ces travaux d'implémentation pratique, on peut voir la mise en place de langages de programmation afin d'interragir avec ces processeurs. Plusieurs constructeurs mettent en place des librairies de développement à disposition du public, en particulier Microsoft avec le Q\# \cite{MicrosoftQuantumDoc}, ou IBM avec Qiskit \cite{Qiskit}. Ces deux solutions sont considérées plutôt haut niveau, et s'intègrent au sein de langages de programmation classiques: tout les langages DotNet et python pour Q\#, et python seulement pour Qiskit. \'A côté de cela, des langages plus bas niveaux existent, en particulier des implémentations langages types assembleur tels que le QASM / OpenQASM \cite{cross2017open}. Ces langages plus bas niveaux permettent, comme les langages plus haut niveau, d'implémenter des circuits quantiques, mais le font avec une syntaxe plus lourde, mais sont exécutables directement sur des processeurs quantiques. Les langages de plus haut niveau compilent vers ces langages assembleurs pour s'exécuter sur des processeurs quantiques.

\section{Simulateurs quantiques}

Un autre champ d'application pratique de l'informatique quantique est l'étude de systèmes physiques difficiles voire impossibles à modéliser avec les supercalculateurs actuels. En 1982, Richard Feynman a été l'un des premiers à proposer un modèle de simulateur quantique universel \cite{Feynman82}. Le concept de ce type d'application est de modéliser des systèmes et problèmes physiques faisant apparaître des comportements quantiques. Ces systèmes entraînent des comportements aujourd'hui mal compris, ne pouvant pas être simulés de façon correcte avec l'informatique classique. Plusieurs champs de la science bénéficieraient ainsi des améliorations apportées par ce domaine, notament la chimie ou la biologie, où on se retrouve avec des systèmes composés de nombreux corps microscopiques avec des interactions quantiques difficiles ou compliquées à modéliser classiquement. Précisément, la difficulté avec la simulation de systèmes quantiques sur des ordinateurs classiques est due à la quantité de mémoire qui serait requise pour modéliser un système quantique dans son entièreté (par exemple, si on veut modéliser un système quantique à deux états purs, composé de $N$ particules, il faudrait $2^N$ nombres en mémoire, et une matrice de taille $2^N \times 2^N$ pour l'évolution du système). 

Plus de détails sur l'implémentation et l'utilisation des simulateurs quantiques sont disponibles, notament par Buluta et Nori en 2009 \cite{Buluta2009}

Aujourd'hui, plusieurs industriels implémentent et mettent à disposition des services dédiés à la simulation quantique. Notament, Microsoft propose intégré au Q\# toute une partie dédiée à ces problèmes. 