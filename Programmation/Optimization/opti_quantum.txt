Constants
    m_amount = 2;
    m_size = 2;
    P1[m_size][m_size] = ((0.1, 0); (0, 0));
    P2[m_size][m_size] = ((0.3,  0.3); (0.3,  0.3));
    P3[m_size][m_size] = ((0, 0); (0,  0.3));
    limit_matrix = 1;

// Tr(m1.m2)
function tr(m1[m_size][m_size], m2[m_size][m_size])
    return m1(1)(1) * m2(1)(1) + m1(1)(2) * m2(2)(1) + m1(2)(1) * m2(1)(2) + m1(2)(2) * m2(2)(2);
end

// base 2 logarithm
function log2(value)
    return ln(value)/ln(2)
end

// Marginal entropy of M
function EntropyM(_M1[m_size][m_size], _M2[m_size][m_size], _M3[m_size][m_size], _P1[m_size][m_size], _P2[m_size][m_size], _P3[m_size][m_size])
    sum_m1 = tr(_M1, _P1) + tr(_M1, _P2) + tr(_M1, _P3);
    sum_m2 = tr(_M2, _P1) + tr(_M2, _P2) + tr(_M2, _P3);
    sum_m3 = tr(_M3, _P1) + tr(_M3, _P2) + tr(_M3, _P3);
    entropy_m = -xlog(sum_m1) - xlog(sum_m2) - xlog(sum_m3);
    return entropy_m;
end

// Marginal entropy of P
function EntropyP(_M1[m_size][m_size], _M2[m_size][m_size], _M3[m_size][m_size], _P1[m_size][m_size], _P2[m_size][m_size], _P3[m_size][m_size])
    sum_p1 = tr(_M1, _P1) + tr(_M2, _P1) + tr(_M3, _P1);
    sum_p2 = tr(_M1, _P2) + tr(_M2, _P2) + tr(_M2, _P2);
    sum_p3 = tr(_M1, _P3) + tr(_M2, _P3) + tr(_M2, _P3);
    entropy_p = -xlog(sum_p1) - xlog(sum_p2) - xlog(sum_p3);
    return entropy_p;
end

// Conditional entropy of M given P
function EntropyM_S_P(_M1[m_size][m_size], _M2[m_size][m_size], _M3[m_size][m_size], _P1[m_size][m_size], _P2[m_size][m_size], _P3[m_size][m_size])
    a11 = tr(_M1, _P1);
    a12 = tr(_M1, _P2);
    a13 = tr(_M1, _P3);

    a21 = tr(_M2, _P1);
    a22 = tr(_M2, _P2);
    a23 = tr(_M2, _P3);

    a31 = tr(_M3, _P1);
    a32 = tr(_M3, _P2);
    a33 = tr(_M3, _P3);

    h1 = -a11 * log2((a11)/(a11 + a12 + a13)) - a12 * log2((a12)/(a11 + a12 + a13)) - a13 * log2((a13)/(a11 + a12 + a13));
    h2 = -a21 * log2((a21)/(a21 + a22 + a23)) - a22 * log2((a22)/(a21 + a22 + a23)) - a23 * log2((a23)/(a21 + a22 + a23));
    h3 = -a31 * log2((a31)/(a31 + a32 + a33)) - a32 * log2((a12)/(a31 + a32 + a33)) - a33 * log2((a13)/(a31 + a32 + a33));
    return h1 + h2 + h3;
end

// Conditional entropy of P given M
function EntropyP_S_M(_M1[m_size][m_size], _M2[m_size][m_size], _M3[m_size][m_size], _P1[m_size][m_size], _P2[m_size][m_size], _P3[m_size][m_size])
    a11 = tr(_M1, _P1);
    a21 = tr(_M2, _P1);
    a31 = tr(_M3, _P1);

    a12 = tr(_M1, _P2);
    a22 = tr(_M2, _P2);
    a32 = tr(_M3, _P2);

    a13 = tr(_M1, _P3);
    a23 = tr(_M2, _P3);
    a33 = tr(_M3, _P3);
    h1 = -a11 * log2((a11)/(a11 + a21 + a31)) - a21 * log2((a21)/(a11 + a21 + a31)) - a31 * log2((a31)/(a11 + a21 + a31));
    h2 = -a12 * log2((a12)/(a12 + a22 + a32)) - a22 * log2((a22)/(a12 + a22 + a32)) - a32 * log2((a32)/(a12 + a22 + a32));
    h3 = -a13 * log2((a13)/(a13 + a23 + a33)) - a23 * log2((a23)/(a13 + a23 + a33)) - a33 * log2((a33)/(a13 + a23 + a33));
    return h1 + h2 + h3;
end

// Joint entropy of M & P
function EntropyMP(_M1[m_size][m_size], _M2[m_size][m_size], _M3[m_size][m_size], _P1[m_size][m_size], _P2[m_size][m_size], _P3[m_size][m_size])
    entropy_mp = xlog(tr(_M1, _P1))  + xlog(tr(_M2, _P1)) + xlog(tr(_M3, _P1))
               + xlog(tr(_M1, _P2))  + xlog(tr(_M2, _P2)) + xlog(tr(_M3, _P2))
               + xlog(tr(_M1, _P3))  + xlog(tr(_M2, _P3)) + xlog(tr(_M3, _P3));
    return -entropy_mp;
end

// Mutual information, using I = H(M) + H(P) - H(M, P) or I = H(M) - H(M|P)
function MutualInformation(_M1[m_size][m_size], _M2[m_size][m_size], _M3[m_size][m_size], _P1[m_size][m_size], _P2[m_size][m_size], _P3[m_size][m_size])
    return EntropyM(_M1, _M2, _M3, _P1, _P2, _P3) + EntropyP(_M1, _M2, _M3, _P1, _P2, _P3) - EntropyMP(_M1, _M2, _M3, _P1, _P2, _P3);
    // return EntropyM(_M1, _M2, _M3, _P1, _P2, _P3) - EntropyM_S_P(_M1, _M2, _M3, _P1, _P2, _P3)
end

// Mutual information
function I(_P1[m_size][m_size], _P2[m_size][m_size], _P3[m_size][m_size], _M1_11, _M1_12, _M1_22, _M2_11, _M2_12, _M2_22, _M3_11, _M3_12, _M3_22)
    _M1 = ((_M1_11, _M1_12); (_M1_12, _M1_22));
    _M2 = ((_M2_11, _M2_12); (_M2_12, _M2_22));
    _M3 = ((_M3_11, _M3_12); (_M3_12, _M3_22));
    res = MutualInformation(_M1, _M2, _M3, _P1, _P2, _P3);
    return res;
end

Variables
    // M1[m_size][m_size] in (([-limit_matrix, limit_matrix], [-limit_matrix, limit_matrix]); ([-limit_matrix, limit_matrix], [-limit_matrix, limit_matrix]));
    // M2[m_size][m_size] in (([-limit_matrix, limit_matrix], [-limit_matrix, limit_matrix]); ([-limit_matrix, limit_matrix], [-limit_matrix, limit_matrix]));
    // M3[m_size][m_size] in (([-limit_matrix, limit_matrix], [-limit_matrix, limit_matrix]); ([-limit_matrix, limit_matrix], [-limit_matrix, limit_matrix]));
    M1_11 in [0, 1], M1_12 in [-1, 1], M1_22 in [0, 1];
    M2_11 in [0, 1], M2_12 in [-1, 1], M2_22 in [0, 1];
    M3_11 in [0, 1], M3_12 in [-1, 1], M3_22 in [0, 1];
    // M3_11 in [0, 1], M3_12 in [-1, 1], M3_22 in [0, 1];
Minimize
    -I(P1, P2, P3, M1_11, M1_12, M1_22, M2_11, M2_12, M2_22, M3_11, M3_12, M3_22);

Constraints
    // Coherent probabilities (sum of probabilities = 1)
    // M1 + M2 + M3 = ((1, 0); (0, 1));
    M1_11 + M2_11 + M3_11 = 1;
    M1_12 + M2_12 + M3_12 = 0;
    M1_22 + M2_22 + M3_22 = 1;

    // EntropyM(((M1_11, M1_12); (M1_12, M1_22)), ((M2_11, M2_12); (M2_12, M2_22)), ((M3_11, M3_12); (M3_12, M3_22)), P1, P2, P3) >= 0;
    // EntropyP(((M1_11, M1_12); (M1_12, M1_22)), ((M2_11, M2_12); (M2_12, M2_22)), ((M3_11, M3_12); (M3_12, M3_22)), P1, P2, P3) >= 0;

    // -I(P1, P2, P3, M1_11, M1_12, M1_22, M2_11, M2_12, M2_22, M3_11, M3_12, M3_22) > -10;

    // Symetric matrices
    // M1(1)(2) = M1(2)(1);
    // M2(1)(2) = M2(2)(1);
    // M3(1)(2) = M3(2)(1);

    //SdP constraints
    // M1(1)(1) > 0;
    // M2(1)(1) > 0;
    // M3(1)(1) > 0;
    // M1(1)(1) * M1(2)(2) - M1(1)(2) * M1(2)(1) > 0;
    // M2(1)(1) * M2(2)(2) - M2(1)(2) * M2(2)(1) > 0;
    // M3(1)(1) * M3(2)(2) - M3(1)(2) * M3(2)(1) > 0;

    M1_11 > 0;
    M2_11 > 0;
    M3_11 > 0;
    M1_22 > 0;
    M2_22 > 0;
    M3_22 > 0;
    M1_11 * M1_22 - M1_12 ^ 2 > 0; // a * b - c^2 > 0 => c^2 < a * b < 1 => c^2 < 1
    M2_11 * M2_22 - M2_12 ^ 2 > 0;
    M3_11 * M3_22 - M3_12 ^ 2 > 0;
end