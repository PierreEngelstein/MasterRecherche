Constants
    P1[2][2] = ((0, 0); (0, 0));
    P2[2][2] = ((0.723,  0.447); (0.447,  0.276));
    P3[2][2] = ((0.276, -0.447); (-0.447, 0.724));
    limit_matrix = 1;

function tr(matrix[2][2])
    return matrix(1)(1) + matrix(2)(2)
end

function log2(value)
    return ln(value)/ln(2)
end

function MutualInformation(_M1[2][2], _M2[2][2], _M3[2][2], _P1[2][2], _P2[2][2], _P3[2][2])
    sum_m1 = tr(_M1 * _P1) + tr(_M1 * _P2) + tr(_M1 * _P3);
    sum_m2 = tr(_M2 * _P1) + tr(_M2 * _P2) + tr(_M2 * _P3);
    sum_m3 = tr(_M3 * _P1) + tr(_M3 * _P2) + tr(_M3 * _P3);
    entropy_m = (sum_m1 * log2(sum_m1) + sum_m2 * log2(sum_m2) + sum_m3 * log2(sum_m3));

    sum_p1 = tr(_M1 * _P1) + tr(_M2 * _P1) + tr(_M3 * _P1);
    sum_p2 = tr(_M1 * _P2) + tr(_M2 * _P2) + tr(_M3 * _P2);
    sum_p3 = tr(_M1 * _P3) + tr(_M2 * _P3) + tr(_M3 * _P3);
    entropy_p = sum_p1 * log2(sum_p1) + sum_p2 * log2(sum_p2) + sum_p3 * log2(sum_p3);

    entropy_mp = tr(_M1 * _P1) * log2(tr(_M1 * _P1))  + tr(_M2 * _P1) * log2(tr(_M2 * _P1)) + tr(_M3 * _P1) * log2(tr(_M3 * _P1))
               + tr(_M1 * _P2) * log2(tr(_M1 * _P2))  + tr(_M2 * _P2) * log2(tr(_M2 * _P2)) + tr(_M3 * _P2) * log2(tr(_M3 * _P2))
               + tr(_M1 * _P3) * log2(tr(_M1 * _P3))  + tr(_M2 * _P3) * log2(tr(_M2 * _P3)) + tr(_M3 * _P3) * log2(tr(_M3 * _P3));

    return entropy_m + entropy_p - entropy_mp;
end

function I(_P1[2][2], _P2[2][2], _P3[2][2], _M1_11, _M1_12, _M1_22, _M2_11, _M2_12, _M2_22, _M3_11, _M3_12, _M3_22)
    _M1 = ((_M1_11, _M1_12); (_M1_12, _M1_22));
    _M2 = ((_M2_11, _M2_12); (_M2_12, _M2_22));
    _M3 = ((_M3_11, _M3_12); (_M3_12, _M3_22));
    res = MutualInformation(_M1, _M2, _M3, _P1, _P2, _P3);
    return res;
end

Variables
    // M1[2][2] in (([-limit_matrix, limit_matrix], [-limit_matrix, limit_matrix]); ([-limit_matrix, limit_matrix], [-limit_matrix, limit_matrix]));
    // M2[2][2] in (([-limit_matrix, limit_matrix], [-limit_matrix, limit_matrix]); ([-limit_matrix, limit_matrix], [-limit_matrix, limit_matrix]));
    // M3[2][2] in (([-limit_matrix, limit_matrix], [-limit_matrix, limit_matrix]); ([-limit_matrix, limit_matrix], [-limit_matrix, limit_matrix]));

    M1_11, M1_12, M1_22;
    M2_11, M2_12, M2_22;
    M3_11, M3_12, M3_22;

Minimize
    // MutualInformation(M1, M2, M3, P1, P2, P3)
    I(P1, P2, P3, M1_11, M1_12, M1_22, M2_11, M2_12, M2_22, M3_11, M3_12, M3_22)

Constraints
    // Coherent probabilities (sum of probabilities = 1)
    // M1 + M2 + M3 = ((1, 0); (0, 1));
    M1_11 + M2_11 + M3_11 = 1;
    M1_12 + M2_12 + M3_12 = 0;
    M1_22 + M2_22 + M3_22 = 1;

    // // Symetric matrices
    // M1(1)(2) = M1(2)(1);
    // M2(1)(2) = M2(2)(1);
    // M3(1)(2) = M3(2)(1);

    // //SdP constraints
    // M1(1)(1) > 0;
    // M2(1)(1) > 0;
    // M3(1)(1) > 0;
    // M1(1)(1) * M1(2)(2) - M1(1)(2) * M1(2)(1) > 0;
    // M2(1)(1) * M2(2)(2) - M2(1)(2) * M2(2)(1) > 0;
    // M3(1)(1) * M3(2)(2) - M3(1)(2) * M3(2)(1) > 0;

    M1_11 > 0;
    M2_11 > 0;
    M3_11 > 0;
    M1_11 * M1_22 - M1_12 * M1_12 > 0;
    M2_11 * M2_22 - M2_12 * M2_12 > 0;
    M3_11 * M3_22 - M3_12 * M3_12 > 0;
end